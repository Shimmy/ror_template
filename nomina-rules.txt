Rules for Rails App Development

Project Context
* This is a Ruby on Rails application.
* Rails Version 8 (Yes it exists, its 2025 now)
* Your base directory is the root of the Rails app.

Scaffolding
* Use the custom generator: rails generate better_scaffold.
* It automatically adds has_many in the associated model when using references.
* Prefer this generator over the default.
* When generating scaffolds, use references where applicable. If unsure, ask the user.
* adding --datatables to better_scaffold gives the user a DataTable.js table, good for lots of data
* Do not remove or alter existing functionality unless explicitly told.

Routing
* Use restful routing with resources
* nest resources when applicable, for example
  resources :blogs do
    resources :ratings
  end

JavaScript (Stimulus)
* Use Stimulus for all frontend interactions.
* Do not add inline JavaScript in HTML.
* Place controllers in app/javascript/controllers/
* Name files like: [controller_name_plural]_controller.js.
* When adding script to layout, make sure you use correct layout file

Stylesheets (Tailwind)
* All views have tailwind css loaded
* Always use tailwind, don't create inline css.
* Try to keep the same layout and style as existing views.

Conventions & Principles
* Stick to Rails conventions unless user instructs otherwise.
* Avoid over-engineering.
* When modifying or adding code, preserve all existing functionality unless told to refactor.

Preinstalled components
* Rails Authenticator is installed
* Current.user and Current.user.id to get the current user
* authenticated? to check if user is authenticated
* Current.user.email_address to get email
* User model is the preinstalled user model, you can not modify it.

Common Commands
* rails generate better_scaffold
* rails db:migrate
* rails db:rollback

Troubleshooting
* When user says something went wrong please check the rails development log
* located in log/development.log
* you probably should not read the whole log since it can be really big
* tail -n50 log/development.log shoud be sufficient if you dont know what you are looking for
* You can also grep the log

WHEN IMPLEMENTING JAVASCRIPTS:

# Integrating JavaScript Libraries with Rails 8 and Turbo

Modern Rails applications using Hotwire and Turbo Drive provide a fast, SPA-like experience, but integrating third-party JavaScript libraries can be challenging. This guide explains how to reliably integrate any JavaScript library with Rails 8 and Turbo.

## The Challenge

Integrating JavaScript libraries with Rails 8 and Turbo presents several challenges:

1. **Lifecycle Management**: Libraries need initialization when pages load and cleanup when navigating away
2. **Importmap Complexity**: Module resolution can be confusing and error-prone
3. **Turbo Navigation**: Standard `DOMContentLoaded` events don't fire during Turbo navigation
4. **State Persistence**: Objects and event listeners may persist across navigations, causing memory leaks

## The Solution: A Universal Approach

This guide presents a universal approach that works for virtually any JavaScript library, whether it's Chart.js, D3.js, Leaflet, Sortable, or any other.

## Step-by-Step Integration Guide

### 1. Choose a Loading Strategy

Pick one of these approaches based on your needs:

#### Option A: CDN Approach (Recommended for simplicity)

Add the library via CDN in your layout file:

```erb
<!-- In app/views/layouts/application.html.erb -->
<head>
  <!-- Other head content -->
  
  <!-- Load your library from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/your-library@version"></script>
</head>
```

#### Option B: Asset Pipeline with jsbundling-rails

For projects requiring bundling:

```bash
# Add jsbundling-rails
bundle add jsbundling-rails
rails javascript:install:esbuild # or webpack/rollup

# Install your library
yarn add your-library

# In your entrypoint file (app/javascript/application.js)
import YourLibrary from 'your-library'
window.YourLibrary = YourLibrary  # Make it globally available
```

#### Option C: Importmap (Rails 8 default)

For libraries compatible with ESM:

```bash
# Pin the library
bin/importmap pin your-library

# This creates entries in config/importmap.rb
# pin "your-library", to: "https://ga.jspm.io/npm:your-library@version/dist/library.js"
```

### 2. Create a Stimulus Controller

Whatever loading strategy you choose, the key is using a Stimulus controller to manage lifecycle:

```bash
rails generate stimulus library-name
```

Edit the controller file (`app/javascript/controllers/library_name_controller.js`):

```javascript
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  // Define targets for elements the library will interact with
  static targets = ["container"]
  
  // Variable to store library instance
  libraryInstance = null
  
  connect() {
    console.log("Library controller connected")
    this.initializeLibrary()
  }
  
  disconnect() {
    // Critical: Clean up when navigating away
    if (this.libraryInstance && typeof this.libraryInstance.destroy === 'function') {
      console.log("Destroying library instance")
      this.libraryInstance.destroy()
    }
    
    // Alternative cleanup approaches based on library:
    
    // 1. For libraries with custom cleanup methods 
    // this.libraryInstance.cleanup()
    
    // 2. For libraries requiring event removal
    // this.containerTarget.removeEventListener('event', this.boundEventHandler)
    
    // 3. For libraries with no cleanup method
    // You may need to manually remove elements or reset state
    
    this.libraryInstance = null
  }
  
  initializeLibrary() {
    // Don't initialize twice
    if (this.libraryInstance) return
    
    console.log("Initializing library")
    
    // Get configuration from data attributes
    const config = JSON.parse(this.element.dataset.libraryConfig || '{}')
    
    // Initialize your library
    // This will vary based on the library's API
    this.libraryInstance = new YourLibrary(this.containerTarget, config)
    
    // OR if your library uses a different initialization pattern:
    // this.libraryInstance = YourLibrary.create(this.containerTarget, config)
  }
}
```

### 3. Use the Controller in Your View

```erb
<div data-controller="library-name"
     data-library-config="<%= { option1: 'value1', option2: 'value2' }.to_json %>">
  <div data-library-name-target="container"></div>
</div>
```

## Handling Common Library Types

Different libraries require slightly different approaches:

### DOM Manipulation Libraries (jQuery, D3.js)

Focus on proper event cleanup:

```javascript
connect() {
  this.boundEventHandler = this.handleEvent.bind(this)
  this.element.addEventListener('click', this.boundEventHandler)
}

disconnect() {
  this.element.removeEventListener('click', this.boundEventHandler)
}
```

### Canvas-Based Libraries (Chart.js, Three.js)

Ensure canvas contexts are properly released:

```javascript
disconnect() {
  if (this.instance) {
    this.instance.destroy()
    // Some libraries need canvas clearing too
    const ctx = this.canvasTarget.getContext('2d')
    ctx.clearRect(0, 0, this.canvasTarget.width, this.canvasTarget.height)
  }
}
```

### Libraries with Custom Events

Register and deregister events:

```javascript
connect() {
  this.library = new Library()
  this.library.on('custom-event', this.handleCustomEvent.bind(this))
}

disconnect() {
  this.library.off('custom-event')
  this.library = null
}
```

## Real-World Example: Sortable.js Integration

Here's how to integrate Sortable.js as a complete example:

1. **Add Sortable.js to your layout**:

```erb
<!-- In app/views/layouts/application.html.erb -->
<head>
  <!-- ... other head content ... -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
```

2. **Create the Stimulus controller**:

```bash
rails generate stimulus sortable
```

3. **Edit the controller**:

```javascript
// app/javascript/controllers/sortable_controller.js
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["list"]
  
  sortable = null
  
  connect() {
    console.log("Sortable controller connected")
    this.initSortable()
  }
  
  disconnect() {
    if (this.sortable) {
      this.sortable.destroy()
      this.sortable = null
    }
  }
  
  initSortable() {
    if (this.sortable) return
    
    const options = JSON.parse(this.element.dataset.sortableOptions || '{}')
    
    // Create Sortable instance
    this.sortable = new Sortable(this.listTarget, {
      animation: 150,
      ...options,
      onEnd: (evt) => {
        // Handle the sorted event
        this.handleSorted(evt)
        
        // Call the original onEnd if provided
        if (options.onEnd) {
          const originalOnEnd = new Function('evt', options.onEnd)
          originalOnEnd(evt)
        }
      }
    })
  }
  
  handleSorted(evt) {
    // Dispatch a custom event with the new order
    const items = Array.from(this.listTarget.children).map(el => el.dataset.id)
    
    this.element.dispatchEvent(new CustomEvent('sorted', {
      detail: { items, oldIndex: evt.oldIndex, newIndex: evt.newIndex }
    }))
    
    // Optionally send the new order to the server
    if (this.element.dataset.updateUrl) {
      this.updateServer(items)
    }
  }
  
  updateServer(items) {
    const url = this.element.dataset.updateUrl
    const token = document.querySelector('meta[name="csrf-token"]').content
    
    fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': token
      },
      body: JSON.stringify({ items })
    })
    .then(response => response.json())
    .then(data => {
      console.log('Success:', data)
    })
    .catch(error => {
      console.error('Error updating order:', error)
    })
  }
}
```

4. **Use in your view**:

```erb
<div data-controller="sortable"
     data-sortable-options="<%= { group: 'tasks', handle: '.handle' }.to_json %>"
     data-update-url="<%= update_order_tasks_path %>">
  <ul data-sortable-target="list">
    <% @tasks.each do |task| %>
      <li data-id="<%= task.id %>">
        <span class="handle">☰</span>
        <%= task.name %>
      </li>
    <% end %>
  </ul>
</div>
```

## Troubleshooting

If you're experiencing issues:

1. **Check browser console**: Look for JavaScript errors or warnings
2. **Verify library loading**: Ensure the library is fully loaded before initialization
3. **Inspect Stimulus lifecycle**: Add console logs to confirm connect/disconnect are working
4. **Test outside Turbo**: Temporarily disable Turbo to isolate issues
5. **DOM integrity**: Ensure elements exist when the library tries to interact with them

## Best Practices

1. **Always destroy instances**: The most critical step for Turbo compatibility
2. **Use data attributes** for configuration to maintain flexibility
3. **Avoid global state** that might persist across navigations
4. **Leverage Stimulus targets** for optimal element selection
5. **Bind event handlers** properly to avoid scope issues
6. **Check library documentation** for proper cleanup methods

## Conclusion

This approach provides a robust pattern for integrating any JavaScript library with Rails 8 and Turbo. By utilizing Stimulus lifecycle hooks to manage initialization and cleanup, you create a reliable integration that works seamlessly with Turbo navigation.

Remember, the key insight is understanding that Turbo navigation requires explicit cleanup and reinitialization of JavaScript components, and Stimulus controllers provide the perfect mechanism for this.
